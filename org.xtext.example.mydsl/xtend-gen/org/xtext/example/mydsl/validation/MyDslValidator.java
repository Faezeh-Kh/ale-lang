/**
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.validation;

import com.google.common.collect.Iterables;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.xtext.example.mydsl.myDsl.FinalCallExpSegment;
import org.xtext.example.mydsl.myDsl.FinalIdentCallSegment;
import org.xtext.example.mydsl.myDsl.FinalIdentSegment;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.RClass;
import org.xtext.example.mydsl.myDsl.RRoot;
import org.xtext.example.mydsl.myDsl.callExp;
import org.xtext.example.mydsl.myDsl.rOperation;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String DUPLICATE_CLASS_NAME = "duplicateClassName";
  
  public final static String DUPLICATE_OPERATION_NAME = "duplicateOperationName";
  
  @Check
  public String typecheckFinalIdentSegment(final FinalIdentSegment finalIdentSegment) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("FinalIdentSegment ");
    String _ident = finalIdentSegment.getIdent();
    _builder.append(_ident, "");
    return InputOutput.<String>println(_builder.toString());
  }
  
  @Check
  public String typecheckFinalIdentCallSegment(final FinalIdentCallSegment finalIdentCallSegment) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("FinalIdentCallSegment ");
    callExp _call = finalIdentCallSegment.getCall();
    _builder.append(_call, "");
    return InputOutput.<String>println(_builder.toString());
  }
  
  @Check
  public String typecheckFinalCallExpSegment(final FinalCallExpSegment finalCallExpSegment) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("FinalCallExpSegment ");
    callExp _call = finalCallExpSegment.getCall();
    _builder.append(_call, "");
    return InputOutput.<String>println(_builder.toString());
  }
  
  @Check
  public void noDuplicateClasses(final RRoot root) {
    EList<RClass> _xtendedClasses = root.getXtendedClasses();
    final Function1<RClass, String> _function = (RClass it) -> {
      return it.getName();
    };
    Map<String, List<RClass>> _groupBy = IterableExtensions.<String, RClass>groupBy(_xtendedClasses, _function);
    final Function2<String, List<RClass>, Boolean> _function_1 = (String p1, List<RClass> p2) -> {
      int _size = p2.size();
      return Boolean.valueOf((_size > 1));
    };
    final Map<String, List<RClass>> duplicateClasses = MapExtensions.<String, List<RClass>>filter(_groupBy, _function_1);
    boolean _isEmpty = duplicateClasses.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      Collection<List<RClass>> _values = duplicateClasses.values();
      Iterable<RClass> _flatten = Iterables.<RClass>concat(_values);
      final Consumer<RClass> _function_2 = (RClass it) -> {
        this.error("Duplicated class name", it, MyDslPackage.Literals.RCLASS__NAME, MyDslValidator.DUPLICATE_CLASS_NAME);
      };
      _flatten.forEach(_function_2);
    }
  }
  
  @Check
  public void noDuplicateMethodsInClass(final RClass openClass) {
    EList<rOperation> _operations = openClass.getOperations();
    final Function1<rOperation, String> _function = (rOperation it) -> {
      return it.getName();
    };
    Map<String, List<rOperation>> _groupBy = IterableExtensions.<String, rOperation>groupBy(_operations, _function);
    final Function2<String, List<rOperation>, Boolean> _function_1 = (String p1, List<rOperation> p2) -> {
      int _size = p2.size();
      return Boolean.valueOf((_size > 1));
    };
    final Map<String, List<rOperation>> duplicateOperations = MapExtensions.<String, List<rOperation>>filter(_groupBy, _function_1);
    boolean _isEmpty = duplicateOperations.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      Collection<List<rOperation>> _values = duplicateOperations.values();
      Iterable<rOperation> _flatten = Iterables.<rOperation>concat(_values);
      final Consumer<rOperation> _function_2 = (rOperation it) -> {
        this.error("Duplicate operation name", it, MyDslPackage.Literals.ROPERATION__NAME, MyDslValidator.DUPLICATE_OPERATION_NAME);
      };
      _flatten.forEach(_function_2);
    }
  }
}
