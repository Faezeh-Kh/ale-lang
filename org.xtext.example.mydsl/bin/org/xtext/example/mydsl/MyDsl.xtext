grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"


/*****************
 * AQL++ grammar *
 *****************/

rRoot returns RRoot: 'behavior' rQualified ';' rImport* rService* xtendedClasses+=rClass*
;

rImport : 'import' rQualified 'as' Ident ';'
;

rService : 'use' Ident ('.' Ident)* ';'
;

rClass returns RClass: 
	{ROpenClass} openClass=rOpenClass | 
	{RNewClass} newClass=rNewClass
;

rOpenClass returns ROpenClass: 'open' 'class' name=rQualified ('extends' rQualified (',' rQualified)* )? '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rNewClass returns RNewClass: 'class' name=rQualified '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rOperation : rTag* ('def' | 'override') type=rType name=Ident '(' paramList+=rParameters? ')' body=rBlock
;

rTag : '@'Ident
;

rParameters : params+=rVariable (',' params+=rVariable)*
;

rVariable : type=rType name=Ident
;

rAttribute : type=rType name=Ident (':=' expr=expression)? ';'
;

rStatement returns RStatement : 
	{RValDecl} stmt=rVarDecl | 
	{RAssign} stmt=rAssign | 
	{RForEach} forEach=rForEach | 
	{RWhile} while=rWhile | 
	{RIf} if=rIf | 
	{RExpression} expr=rExpression
;

rVarDecl : rType Ident (':=' expression)? ';'
;

rAssign returns RAssign: left=expression ':=' right=expression ';'
;

rForEach returns RForEach: 'for' '(' Ident  'in' rCollection ')' block=rBlock
;

rCollection : '[' INT '..' INT ']' | expression
;

rBlock : '{' (statement+=rStatement (statement+=rStatement)*)? '}'
;

rIf returns RIf: 'if' '(' condition=expression ')' ifBlock=rBlock ('else' elseBlock=rBlock)?
;

rWhile returns RWhile : 'while' '(' expression ')' block=rBlock
;

rExpression returns RExpression: expression ';'
;

/***************
 * AQL grammar *
 ***************/

expression returns Expr:
	leftPart=nonLeftRecExpression recpart=recExpression?
;

recExpression returns RecExpression:
	(navigationSegment | MultOp expression | addOp expression | compOp expression | 'and' expression | 'or' expression | 'xor' expression | 'implies' expression) recExp=recExpression?
;

navigationSegment returns NavigationSegment:     
	{FinalIdentSegment} '.'ident=Ident | 
  	{FinalIdentCallSegment} '.' call=callExp | 
  	{FinalCallExpSegment} '->' call=callExp
;    

nonLeftRecExpression :
              'not' expression
		     | '-' expression
		     | Ident
		     | literal
		     | '(' expression ')'
		     | 'if' condition=expression 'then' ifBlock=expression 'else' elseBlock=expression 'endif'
		     | 'let' bindings+=binding (',' bindings+=binding)* 'in' letExpr=expression
;

binding : Ident (':' typeLiteral)? '=' expression
;

addOp: '+' | '-'
;

compOp :     '<='
	    	|'>='
	  		|'!='
	  		|'<>'
	  		|'='
	  		|'=='
	 		|'<'
	  		|'>'
;


callExp :     collectionIterator '(' variableDefinition expression ')'
			| Ident'(' expressionSequence ')'
;

collectionIterator : 'select' | 'reject' | 'collect' | 'any' | 'exists' | 'forAll' | 'isUnique' | 'one' | 'sortedBy' | 'closure'
;

expressionSequence : (seqExprs+=expression (',' seqExprs+=expression)*)?
;

variableDefinition : Ident (':' typeLiteral)? '|'
;

literal :    STRING
		   | INT
		   | Real
		   |'true'
		   |'false'
		   |'null'
		   |'Sequence{' expressionSequence '}'
		   |'OrderedSet{' expressionSequence '}'
		   | Ident '::' Ident '::' Ident
		   | Ident '::' Ident ':'
		   | typeLiteral
;

typeLiteral :   'String'
		      | 'Integer'
		      | 'Real'
		      | 'Boolean'
		      | 'Sequence(' typeLiteral')'
		      | 'OrderedSet(' typeLiteral')'
		      | classifierTypeRule
		      | '{' classifierTypeRule ('|' classifierTypeRule)* '}'
;

classifierTypeRule :   Ident '::' Ident
				     | Ident ':' 
;

rType: rQualified | typeLiteral
;

rQualified : Ident ('.'Ident)*
;

terminal MultOp : '*' | '/'
;

terminal Real : ('0'..'9')+'.'('0'..'9')+
;

terminal Ident : (Letter | '_') (Letter | '0'..'9' | '_')*
;

terminal Letter : ('a'..'z'|'A'..'Z')
;