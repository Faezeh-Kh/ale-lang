/*
 * generated by Xtext 2.10.0
 */
package org.eclipse.ecoretools.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.ecoretools.ale.AlePackage;
<<<<<<< HEAD
import org.eclipse.ecoretools.ale.Binding;
import org.eclipse.ecoretools.ale.ClassExp;
import org.eclipse.ecoretools.ale.Expr;
import org.eclipse.ecoretools.ale.FinalCallExpSegment;
import org.eclipse.ecoretools.ale.FinalIdentCallSegment;
import org.eclipse.ecoretools.ale.FinalIdentSegment;
import org.eclipse.ecoretools.ale.IdentifierExpresion;
import org.eclipse.ecoretools.ale.IfExpression;
import org.eclipse.ecoretools.ale.LetExpression;
import org.eclipse.ecoretools.ale.LiteralExpressioin;
import org.eclipse.ecoretools.ale.NegExpression;
import org.eclipse.ecoretools.ale.NotExpression;
import org.eclipse.ecoretools.ale.ParenthesisExpression;
import org.eclipse.ecoretools.ale.RAssign;
import org.eclipse.ecoretools.ale.RExpression;
import org.eclipse.ecoretools.ale.RForEach;
import org.eclipse.ecoretools.ale.RIf;
import org.eclipse.ecoretools.ale.RNewClass;
import org.eclipse.ecoretools.ale.ROpenClass;
import org.eclipse.ecoretools.ale.RRoot;
import org.eclipse.ecoretools.ale.RValDecl;
import org.eclipse.ecoretools.ale.RWhile;
import org.eclipse.ecoretools.ale.TypeLiteralBoolean;
import org.eclipse.ecoretools.ale.TypeLiteralClassifier;
import org.eclipse.ecoretools.ale.TypeLiteralInteger;
import org.eclipse.ecoretools.ale.TypeLiteralOrderedTypeSet;
import org.eclipse.ecoretools.ale.TypeLiteralPipe;
import org.eclipse.ecoretools.ale.TypeLiteralReal;
import org.eclipse.ecoretools.ale.TypeLiteralSequence;
import org.eclipse.ecoretools.ale.TypeLiteralString;
import org.eclipse.ecoretools.ale.expressionSequence;
import org.eclipse.ecoretools.ale.rAttribute;
import org.eclipse.ecoretools.ale.rBlock;
import org.eclipse.ecoretools.ale.rOperation;
import org.eclipse.ecoretools.ale.rParameters;
import org.eclipse.ecoretools.ale.rVarDecl;
=======
import org.eclipse.ecoretools.ale.rAttribute;
import org.eclipse.ecoretools.ale.rNewClass;
import org.eclipse.ecoretools.ale.rOpenClass;
import org.eclipse.ecoretools.ale.rOperation;
import org.eclipse.ecoretools.ale.rParameters;
import org.eclipse.ecoretools.ale.rRoot;
>>>>>>> local-ale-lang
import org.eclipse.ecoretools.ale.rVariable;
import org.eclipse.ecoretools.services.AleGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AlePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
<<<<<<< HEAD
			case AlePackage.BINDING:
				sequence_binding(context, (Binding) semanticObject); 
				return; 
			case AlePackage.CLASS_EXP:
				sequence_callExp(context, (ClassExp) semanticObject); 
				return; 
			case AlePackage.EXPR:
				if (rule == grammarAccess.getRCollectionRule()
						|| rule == grammarAccess.getRExpressionRule()
						|| rule == grammarAccess.getExpressionRule()) {
					sequence_expression(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRForEachRule()) {
					sequence_expression_rForEach(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRWhileRule()) {
					sequence_expression_rWhile(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_expression_recExpression(context, (Expr) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.FINAL_CALL_EXP_SEGMENT:
				if (rule == grammarAccess.getNavigationSegmentRule()) {
					sequence_navigationSegment(context, (FinalCallExpSegment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_navigationSegment_recExpression(context, (FinalCallExpSegment) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.FINAL_IDENT_CALL_SEGMENT:
				if (rule == grammarAccess.getNavigationSegmentRule()) {
					sequence_navigationSegment(context, (FinalIdentCallSegment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_navigationSegment_recExpression(context, (FinalIdentCallSegment) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.FINAL_IDENT_SEGMENT:
				if (rule == grammarAccess.getNavigationSegmentRule()) {
					sequence_navigationSegment(context, (FinalIdentSegment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_navigationSegment_recExpression(context, (FinalIdentSegment) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.IDENTIFIER_EXPRESION:
				sequence_nonLeftRecExpression(context, (IdentifierExpresion) semanticObject); 
				return; 
			case AlePackage.IF_EXPRESSION:
				sequence_nonLeftRecExpression(context, (IfExpression) semanticObject); 
				return; 
			case AlePackage.LET_EXPRESSION:
				sequence_nonLeftRecExpression(context, (LetExpression) semanticObject); 
				return; 
			case AlePackage.LITERAL_EXPRESSIOIN:
				sequence_nonLeftRecExpression(context, (LiteralExpressioin) semanticObject); 
				return; 
			case AlePackage.NEG_EXPRESSION:
				sequence_nonLeftRecExpression(context, (NegExpression) semanticObject); 
				return; 
			case AlePackage.NOT_EXPRESSION:
				sequence_nonLeftRecExpression(context, (NotExpression) semanticObject); 
				return; 
			case AlePackage.PARENTHESIS_EXPRESSION:
				sequence_nonLeftRecExpression(context, (ParenthesisExpression) semanticObject); 
				return; 
			case AlePackage.RASSIGN:
				if (rule == grammarAccess.getRAssignRule()) {
					sequence_rAssign(context, (RAssign) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRStatementRule()) {
					sequence_rStatement(context, (RAssign) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.REXPRESSION:
				sequence_rStatement(context, (RExpression) semanticObject); 
				return; 
			case AlePackage.RFOR_EACH:
				if (rule == grammarAccess.getRForEachRule()) {
					sequence_rForEach(context, (RForEach) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRStatementRule()) {
					sequence_rStatement(context, (RForEach) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.RIF:
				if (rule == grammarAccess.getRIfRule()) {
					sequence_rIf(context, (RIf) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRStatementRule()) {
					sequence_rStatement(context, (RIf) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.RNEW_CLASS:
				if (rule == grammarAccess.getRClassRule()) {
					sequence_rClass(context, (RNewClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRNewClassRule()) {
					sequence_rNewClass(context, (RNewClass) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.ROPEN_CLASS:
				if (rule == grammarAccess.getRClassRule()) {
					sequence_rClass(context, (ROpenClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getROpenClassRule()) {
					sequence_rOpenClass(context, (ROpenClass) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.RROOT:
				sequence_rRoot(context, (RRoot) semanticObject); 
				return; 
			case AlePackage.RVAL_DECL:
				sequence_rStatement(context, (RValDecl) semanticObject); 
				return; 
			case AlePackage.RWHILE:
				sequence_rStatement(context, (RWhile) semanticObject); 
				return; 
			case AlePackage.TYPE_LITERAL_BOOLEAN:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralBoolean) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralBoolean) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.TYPE_LITERAL_CLASSIFIER:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralClassifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralClassifier) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.TYPE_LITERAL_INTEGER:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralInteger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralInteger) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.TYPE_LITERAL_ORDERED_TYPE_SET:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralOrderedTypeSet) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralOrderedTypeSet) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.TYPE_LITERAL_PIPE:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralPipe) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralPipe) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.TYPE_LITERAL_REAL:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralReal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralReal) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.TYPE_LITERAL_SEQUENCE:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralSequence) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralSequence) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.TYPE_LITERAL_STRING:
				if (rule == grammarAccess.getCallExpRule()) {
					sequence_callExp_typeLiteral(context, (TypeLiteralString) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDefinitionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTypeLiteralRule()
						|| rule == grammarAccess.getRTypeRule()) {
					sequence_typeLiteral(context, (TypeLiteralString) semanticObject); 
					return; 
				}
				else break;
			case AlePackage.EXPRESSION_SEQUENCE:
				sequence_expressionSequence(context, (expressionSequence) semanticObject); 
				return; 
			case AlePackage.RATTRIBUTE:
				sequence_rAttribute(context, (rAttribute) semanticObject); 
				return; 
			case AlePackage.RBLOCK:
				sequence_rBlock(context, (rBlock) semanticObject); 
=======
			case AlePackage.RATTRIBUTE:
				sequence_rAttribute(context, (rAttribute) semanticObject); 
				return; 
			case AlePackage.RNEW_CLASS:
				sequence_rNewClass(context, (rNewClass) semanticObject); 
				return; 
			case AlePackage.ROPEN_CLASS:
				sequence_rOpenClass(context, (rOpenClass) semanticObject); 
>>>>>>> local-ale-lang
				return; 
			case AlePackage.ROPERATION:
				sequence_rOperation(context, (rOperation) semanticObject); 
				return; 
			case AlePackage.RPARAMETERS:
				sequence_rParameters(context, (rParameters) semanticObject); 
				return; 
<<<<<<< HEAD
			case AlePackage.RVAR_DECL:
				sequence_rVarDecl(context, (rVarDecl) semanticObject); 
=======
			case AlePackage.RROOT:
				sequence_rRoot(context, (rRoot) semanticObject); 
>>>>>>> local-ale-lang
				return; 
			case AlePackage.RVARIABLE:
				sequence_rVariable(context, (rVariable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
<<<<<<< HEAD
	 *     binding returns Binding
	 *
	 * Constraint:
	 *     (identifier=IDENT type=typeLiteral? expression=expression)
	 */
	protected void sequence_binding(ISerializationContext context, Binding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns ClassExp
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_callExp(ISerializationContext context, ClassExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralBoolean
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralClassifier
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralClassifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralInteger
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralOrderedTypeSet
	 *
	 * Constraint:
	 *     (subType=typeLiteral expression=expression)
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralOrderedTypeSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.TYPE_LITERAL_ORDERED_TYPE_SET__SUB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.TYPE_LITERAL_ORDERED_TYPE_SET__SUB_TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeLiteralAccess().getSubTypeTypeLiteralParserRuleCall_5_2_0(), semanticObject.getSubType());
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralPipe
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralPipe semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralReal
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralReal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralSequence
	 *
	 * Constraint:
	 *     (subType=typeLiteral expression=expression)
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralSequence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.TYPE_LITERAL_SEQUENCE__SUB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.TYPE_LITERAL_SEQUENCE__SUB_TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeLiteralAccess().getSubTypeTypeLiteralParserRuleCall_4_2_0(), semanticObject.getSubType());
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callExp returns TypeLiteralString
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_callExp_typeLiteral(ISerializationContext context, TypeLiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VARIABLE_DEFINITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallExpAccess().getExpressionExpressionParserRuleCall_0_3_0(), semanticObject.getExpression());
=======
	 *     rAttribute returns rAttribute
	 *
	 * Constraint:
	 *     (type=rType name=Ident)
	 */
	protected void sequence_rAttribute(ISerializationContext context, rAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RATTRIBUTE__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRAttributeAccess().getTypeRTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getRAttributeAccess().getNameIdentTerminalRuleCall_1_0(), semanticObject.getName());
>>>>>>> local-ale-lang
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
<<<<<<< HEAD
	 *     callExp returns expressionSequence
	 *     expressionSequence returns expressionSequence
	 *     literal returns expressionSequence
	 *
	 * Constraint:
	 *     (seqExprs+=expression seqExprs+=expression*)
	 */
	protected void sequence_expressionSequence(ISerializationContext context, expressionSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rCollection returns Expr
	 *     rExpression returns Expr
	 *     expression returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression?)
	 */
	protected void sequence_expression(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rForEach returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression? block=rBlock)
	 */
	protected void sequence_expression_rForEach(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rWhile returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression? block=rBlock)
	 */
	protected void sequence_expression_rWhile(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recExpression returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression? recExp=recExpression?)
	 */
	protected void sequence_expression_recExpression(ISerializationContext context, Expr semanticObject) {
=======
	 *     rClass returns rNewClass
	 *     rNewClass returns rNewClass
	 *
	 * Constraint:
	 *     (name=Ident attributes+=rAttribute* operations+=rOperation*)
	 */
	protected void sequence_rNewClass(ISerializationContext context, rNewClass semanticObject) {
>>>>>>> local-ale-lang
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
<<<<<<< HEAD
	 *     navigationSegment returns FinalCallExpSegment
	 *
	 * Constraint:
	 *     call=callExp
	 */
	protected void sequence_navigationSegment(ISerializationContext context, FinalCallExpSegment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FINAL_CALL_EXP_SEGMENT__CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FINAL_CALL_EXP_SEGMENT__CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationSegmentAccess().getCallCallExpParserRuleCall_2_2_0(), semanticObject.getCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     navigationSegment returns FinalIdentCallSegment
	 *
	 * Constraint:
	 *     call=callExp
	 */
	protected void sequence_navigationSegment(ISerializationContext context, FinalIdentCallSegment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FINAL_IDENT_CALL_SEGMENT__CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FINAL_IDENT_CALL_SEGMENT__CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationSegmentAccess().getCallCallExpParserRuleCall_1_2_0(), semanticObject.getCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     navigationSegment returns FinalIdentSegment
	 *
	 * Constraint:
	 *     ident=IDENT
	 */
	protected void sequence_navigationSegment(ISerializationContext context, FinalIdentSegment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FINAL_IDENT_SEGMENT__IDENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FINAL_IDENT_SEGMENT__IDENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationSegmentAccess().getIdentIDENTTerminalRuleCall_0_2_0(), semanticObject.getIdent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recExpression returns FinalCallExpSegment
	 *
	 * Constraint:
	 *     (call=callExp recExp=recExpression?)
	 */
	protected void sequence_navigationSegment_recExpression(ISerializationContext context, FinalCallExpSegment semanticObject) {
=======
	 *     rClass returns rOpenClass
	 *     rOpenClass returns rOpenClass
	 *
	 * Constraint:
	 *     (name=rQualified attributes+=rAttribute* operations+=rOperation*)
	 */
	protected void sequence_rOpenClass(ISerializationContext context, rOpenClass semanticObject) {
>>>>>>> local-ale-lang
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
<<<<<<< HEAD
	 *     recExpression returns FinalIdentCallSegment
	 *
	 * Constraint:
	 *     (call=callExp recExp=recExpression?)
	 */
	protected void sequence_navigationSegment_recExpression(ISerializationContext context, FinalIdentCallSegment semanticObject) {
=======
	 *     rOperation returns rOperation
	 *
	 * Constraint:
	 *     (type=rType name=Ident paramList+=rParameters? body=rBlock)
	 */
	protected void sequence_rOperation(ISerializationContext context, rOperation semanticObject) {
>>>>>>> local-ale-lang
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
<<<<<<< HEAD
	 *     recExpression returns FinalIdentSegment
	 *
	 * Constraint:
	 *     (ident=IDENT recExp=recExpression?)
	 */
	protected void sequence_navigationSegment_recExpression(ISerializationContext context, FinalIdentSegment semanticObject) {
=======
	 *     rParameters returns rParameters
	 *
	 * Constraint:
	 *     (params+=rVariable params+=rVariable*)
	 */
	protected void sequence_rParameters(ISerializationContext context, rParameters semanticObject) {
>>>>>>> local-ale-lang
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
<<<<<<< HEAD
	 *     nonLeftRecExpression returns IdentifierExpresion
	 *
	 * Constraint:
	 *     value=IDENT
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, IdentifierExpresion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IDENTIFIER_EXPRESION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IDENTIFIER_EXPRESION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getValueIDENTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     nonLeftRecExpression returns IfExpression
	 *
	 * Constraint:
	 *     (condition=expression ifBlock=expression elseBlock=expression)
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, IfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IF_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IF_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IF_EXPRESSION__IF_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IF_EXPRESSION__IF_BLOCK));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IF_EXPRESSION__ELSE_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IF_EXPRESSION__ELSE_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getConditionExpressionParserRuleCall_5_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getIfBlockExpressionParserRuleCall_5_4_0(), semanticObject.getIfBlock());
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getElseBlockExpressionParserRuleCall_5_6_0(), semanticObject.getElseBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     nonLeftRecExpression returns LetExpression
	 *
	 * Constraint:
	 *     (bindings+=binding bindings+=binding* letExpr=expression)
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, LetExpression semanticObject) {
=======
	 *     rRoot returns rRoot
	 *
	 * Constraint:
	 *     xtendedClasses+=rClass+
	 */
	protected void sequence_rRoot(ISerializationContext context, rRoot semanticObject) {
>>>>>>> local-ale-lang
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
<<<<<<< HEAD
	 *     nonLeftRecExpression returns LiteralExpressioin
	 *
	 * Constraint:
	 *     lit=literal
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, LiteralExpressioin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.LITERAL_EXPRESSIOIN__LIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.LITERAL_EXPRESSIOIN__LIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getLitLiteralParserRuleCall_3_1_0(), semanticObject.getLit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     nonLeftRecExpression returns NegExpression
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, NegExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.NEG_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.NEG_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getExpressionExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
=======
	 *     rVariable returns rVariable
	 *
	 * Constraint:
	 *     (type=rType name=Ident)
	 */
	protected void sequence_rVariable(ISerializationContext context, rVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RVARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RVARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RVARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RVARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRVariableAccess().getTypeRTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getRVariableAccess().getNameIdentTerminalRuleCall_1_0(), semanticObject.getName());
>>>>>>> local-ale-lang
		feeder.finish();
	}
	
	
<<<<<<< HEAD
	/**
	 * Contexts:
	 *     nonLeftRecExpression returns NotExpression
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.NOT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.NOT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getExpressionExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     nonLeftRecExpression returns ParenthesisExpression
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, ParenthesisExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.PARENTHESIS_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.PARENTHESIS_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonLeftRecExpressionAccess().getExpressionExpressionParserRuleCall_4_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rAssign returns RAssign
	 *
	 * Constraint:
	 *     (left=expression right=expression)
	 */
	protected void sequence_rAssign(ISerializationContext context, RAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RASSIGN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RASSIGN__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RASSIGN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RASSIGN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRAssignAccess().getLeftExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRAssignAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rAttribute returns rAttribute
	 *
	 * Constraint:
	 *     (type=rType name=IDENT expr=expression?)
	 */
	protected void sequence_rAttribute(ISerializationContext context, rAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rBlock returns rBlock
	 *
	 * Constraint:
	 *     (statement+=rStatement statement+=rStatement*)
	 */
	protected void sequence_rBlock(ISerializationContext context, rBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rClass returns RNewClass
	 *
	 * Constraint:
	 *     newClass=rNewClass
	 */
	protected void sequence_rClass(ISerializationContext context, RNewClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RNEW_CLASS__NEW_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RNEW_CLASS__NEW_CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRClassAccess().getNewClassRNewClassParserRuleCall_1_1_0(), semanticObject.getNewClass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rClass returns ROpenClass
	 *
	 * Constraint:
	 *     openClass=rOpenClass
	 */
	protected void sequence_rClass(ISerializationContext context, ROpenClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.ROPEN_CLASS__OPEN_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.ROPEN_CLASS__OPEN_CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRClassAccess().getOpenClassROpenClassParserRuleCall_0_1_0(), semanticObject.getOpenClass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rForEach returns RForEach
	 *
	 * Constraint:
	 *     block=rBlock
	 */
	protected void sequence_rForEach(ISerializationContext context, RForEach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rIf returns RIf
	 *
	 * Constraint:
	 *     (condition=expression ifBlock=rBlock elseBlock=rBlock?)
	 */
	protected void sequence_rIf(ISerializationContext context, RIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rNewClass returns RNewClass
	 *
	 * Constraint:
	 *     (name=rQualified attributes+=rAttribute* operations+=rOperation*)
	 */
	protected void sequence_rNewClass(ISerializationContext context, RNewClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rOpenClass returns ROpenClass
	 *
	 * Constraint:
	 *     (name=rQualified attributes+=rAttribute* operations+=rOperation*)
	 */
	protected void sequence_rOpenClass(ISerializationContext context, ROpenClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rOperation returns rOperation
	 *
	 * Constraint:
	 *     (type=rType name=IDENT paramList+=rParameters? body=rBlock)
	 */
	protected void sequence_rOperation(ISerializationContext context, rOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rParameters returns rParameters
	 *
	 * Constraint:
	 *     (params+=rVariable params+=rVariable*)
	 */
	protected void sequence_rParameters(ISerializationContext context, rParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rRoot returns RRoot
	 *
	 * Constraint:
	 *     xtendedClasses+=rClass+
	 */
	protected void sequence_rRoot(ISerializationContext context, RRoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RAssign
	 *
	 * Constraint:
	 *     stmt=rAssign
	 */
	protected void sequence_rStatement(ISerializationContext context, RAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RASSIGN__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RASSIGN__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getStmtRAssignParserRuleCall_1_1_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RExpression
	 *
	 * Constraint:
	 *     expr=rExpression
	 */
	protected void sequence_rStatement(ISerializationContext context, RExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.REXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.REXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getExprRExpressionParserRuleCall_5_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RForEach
	 *
	 * Constraint:
	 *     forEach=rForEach
	 */
	protected void sequence_rStatement(ISerializationContext context, RForEach semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RFOR_EACH__FOR_EACH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RFOR_EACH__FOR_EACH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getForEachRForEachParserRuleCall_2_1_0(), semanticObject.getForEach());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RIf
	 *
	 * Constraint:
	 *     if=rIf
	 */
	protected void sequence_rStatement(ISerializationContext context, RIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RIF__IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RIF__IF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getIfRIfParserRuleCall_4_1_0(), semanticObject.getIf());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RValDecl
	 *
	 * Constraint:
	 *     stmt=rVarDecl
	 */
	protected void sequence_rStatement(ISerializationContext context, RValDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RVAL_DECL__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RVAL_DECL__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getStmtRVarDeclParserRuleCall_0_1_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RWhile
	 *
	 * Constraint:
	 *     while=rWhile
	 */
	protected void sequence_rStatement(ISerializationContext context, RWhile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RWHILE__WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RWHILE__WHILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getWhileRWhileParserRuleCall_3_1_0(), semanticObject.getWhile());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rVarDecl returns rVarDecl
	 *
	 * Constraint:
	 *     (type=rType ident=IDENT expression=expression?)
	 */
	protected void sequence_rVarDecl(ISerializationContext context, rVarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rVariable returns rVariable
	 *
	 * Constraint:
	 *     (type=rType name=IDENT)
	 */
	protected void sequence_rVariable(ISerializationContext context, rVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RVARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RVARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RVARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RVARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRVariableAccess().getTypeRTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getRVariableAccess().getNameIDENTTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralBoolean
	 *     literal returns TypeLiteralBoolean
	 *     typeLiteral returns TypeLiteralBoolean
	 *     rType returns TypeLiteralBoolean
	 *
	 * Constraint:
	 *     {TypeLiteralBoolean}
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralClassifier
	 *     literal returns TypeLiteralClassifier
	 *     typeLiteral returns TypeLiteralClassifier
	 *     rType returns TypeLiteralClassifier
	 *
	 * Constraint:
	 *     {TypeLiteralClassifier}
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralClassifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralInteger
	 *     literal returns TypeLiteralInteger
	 *     typeLiteral returns TypeLiteralInteger
	 *     rType returns TypeLiteralInteger
	 *
	 * Constraint:
	 *     {TypeLiteralInteger}
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralOrderedTypeSet
	 *     literal returns TypeLiteralOrderedTypeSet
	 *     typeLiteral returns TypeLiteralOrderedTypeSet
	 *     rType returns TypeLiteralOrderedTypeSet
	 *
	 * Constraint:
	 *     subType=typeLiteral
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralOrderedTypeSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.TYPE_LITERAL_ORDERED_TYPE_SET__SUB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.TYPE_LITERAL_ORDERED_TYPE_SET__SUB_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeLiteralAccess().getSubTypeTypeLiteralParserRuleCall_5_2_0(), semanticObject.getSubType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralPipe
	 *     literal returns TypeLiteralPipe
	 *     typeLiteral returns TypeLiteralPipe
	 *     rType returns TypeLiteralPipe
	 *
	 * Constraint:
	 *     {TypeLiteralPipe}
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralPipe semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralReal
	 *     literal returns TypeLiteralReal
	 *     typeLiteral returns TypeLiteralReal
	 *     rType returns TypeLiteralReal
	 *
	 * Constraint:
	 *     {TypeLiteralReal}
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralReal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralSequence
	 *     literal returns TypeLiteralSequence
	 *     typeLiteral returns TypeLiteralSequence
	 *     rType returns TypeLiteralSequence
	 *
	 * Constraint:
	 *     subType=typeLiteral
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralSequence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.TYPE_LITERAL_SEQUENCE__SUB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.TYPE_LITERAL_SEQUENCE__SUB_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeLiteralAccess().getSubTypeTypeLiteralParserRuleCall_4_2_0(), semanticObject.getSubType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     variableDefinition returns TypeLiteralString
	 *     literal returns TypeLiteralString
	 *     typeLiteral returns TypeLiteralString
	 *     rType returns TypeLiteralString
	 *
	 * Constraint:
	 *     {TypeLiteralString}
	 */
	protected void sequence_typeLiteral(ISerializationContext context, TypeLiteralString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
=======
>>>>>>> local-ale-lang
}
