/*
 * generated by Xtext 2.10.0
 */
package org.eclipse.ecoretools.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.ecoretools.ale.AlePackage;
import org.eclipse.ecoretools.ale.rAttribute;
import org.eclipse.ecoretools.ale.rNewClass;
import org.eclipse.ecoretools.ale.rOpenClass;
import org.eclipse.ecoretools.ale.rOperation;
import org.eclipse.ecoretools.ale.rParameters;
import org.eclipse.ecoretools.ale.rRoot;
import org.eclipse.ecoretools.ale.rVariable;
import org.eclipse.ecoretools.services.AleGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
<<<<<<< HEAD:org.xtext.example.mydsl/src-gen/org/xtext/example/mydsl/serializer/MyDslSemanticSequencer.java
import org.xtext.example.mydsl.myDsl.Expr;
import org.xtext.example.mydsl.myDsl.FinalCallExpSegment;
import org.xtext.example.mydsl.myDsl.FinalIdentCallSegment;
import org.xtext.example.mydsl.myDsl.FinalIdentSegment;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.RAssign;
import org.xtext.example.mydsl.myDsl.RExpression;
import org.xtext.example.mydsl.myDsl.RForEach;
import org.xtext.example.mydsl.myDsl.RIf;
import org.xtext.example.mydsl.myDsl.RNewClass;
import org.xtext.example.mydsl.myDsl.ROpenClass;
import org.xtext.example.mydsl.myDsl.RRoot;
import org.xtext.example.mydsl.myDsl.RValDecl;
import org.xtext.example.mydsl.myDsl.RWhile;
import org.xtext.example.mydsl.myDsl.expressionSequence;
import org.xtext.example.mydsl.myDsl.nonLeftRecExpression;
import org.xtext.example.mydsl.myDsl.rAttribute;
import org.xtext.example.mydsl.myDsl.rBlock;
import org.xtext.example.mydsl.myDsl.rOperation;
import org.xtext.example.mydsl.myDsl.rParameters;
import org.xtext.example.mydsl.myDsl.rVariable;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;
=======
>>>>>>> master:org.eclipse.ecoretools.ale.xtext/src-gen/org/eclipse/ecoretools/serializer/AleSemanticSequencer.java

@SuppressWarnings("all")
public class AleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AlePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
<<<<<<< HEAD:org.xtext.example.mydsl/src-gen/org/xtext/example/mydsl/serializer/MyDslSemanticSequencer.java
			case MyDslPackage.EXPR:
				if (rule == grammarAccess.getRVarDeclRule()
						|| rule == grammarAccess.getRCollectionRule()
						|| rule == grammarAccess.getRExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getNonLeftRecExpressionRule()
						|| rule == grammarAccess.getBindingRule()
						|| rule == grammarAccess.getCallExpRule()) {
					sequence_expression(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRForEachRule()) {
					sequence_expression_rForEach(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRWhileRule()) {
					sequence_expression_rWhile(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_expression_recExpression(context, (Expr) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FINAL_CALL_EXP_SEGMENT:
				if (rule == grammarAccess.getNavigationSegmentRule()) {
					sequence_navigationSegment(context, (FinalCallExpSegment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_navigationSegment_recExpression(context, (FinalCallExpSegment) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FINAL_IDENT_CALL_SEGMENT:
				if (rule == grammarAccess.getNavigationSegmentRule()) {
					sequence_navigationSegment(context, (FinalIdentCallSegment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_navigationSegment_recExpression(context, (FinalIdentCallSegment) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FINAL_IDENT_SEGMENT:
				if (rule == grammarAccess.getNavigationSegmentRule()) {
					sequence_navigationSegment(context, (FinalIdentSegment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecExpressionRule()) {
					sequence_navigationSegment_recExpression(context, (FinalIdentSegment) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.RASSIGN:
				if (rule == grammarAccess.getRAssignRule()) {
					sequence_rAssign(context, (RAssign) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRStatementRule()) {
					sequence_rStatement(context, (RAssign) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.REXPRESSION:
				sequence_rStatement(context, (RExpression) semanticObject); 
				return; 
			case MyDslPackage.RFOR_EACH:
				if (rule == grammarAccess.getRForEachRule()) {
					sequence_rForEach(context, (RForEach) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRStatementRule()) {
					sequence_rStatement(context, (RForEach) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.RIF:
				if (rule == grammarAccess.getRIfRule()) {
					sequence_rIf(context, (RIf) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRStatementRule()) {
					sequence_rStatement(context, (RIf) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.RNEW_CLASS:
				if (rule == grammarAccess.getRClassRule()) {
					sequence_rClass(context, (RNewClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRNewClassRule()) {
					sequence_rNewClass(context, (RNewClass) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.ROPEN_CLASS:
				if (rule == grammarAccess.getRClassRule()) {
					sequence_rClass(context, (ROpenClass) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getROpenClassRule()) {
					sequence_rOpenClass(context, (ROpenClass) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.RROOT:
				sequence_rRoot(context, (RRoot) semanticObject); 
				return; 
			case MyDslPackage.RVAL_DECL:
				sequence_rStatement(context, (RValDecl) semanticObject); 
				return; 
			case MyDslPackage.RWHILE:
				sequence_rStatement(context, (RWhile) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION_SEQUENCE:
				sequence_expressionSequence(context, (expressionSequence) semanticObject); 
				return; 
			case MyDslPackage.NON_LEFT_REC_EXPRESSION:
				sequence_nonLeftRecExpression(context, (nonLeftRecExpression) semanticObject); 
				return; 
			case MyDslPackage.RATTRIBUTE:
				sequence_rAttribute(context, (rAttribute) semanticObject); 
				return; 
			case MyDslPackage.RBLOCK:
				sequence_rBlock(context, (rBlock) semanticObject); 
=======
			case AlePackage.RATTRIBUTE:
				sequence_rAttribute(context, (rAttribute) semanticObject); 
				return; 
			case AlePackage.RNEW_CLASS:
				sequence_rNewClass(context, (rNewClass) semanticObject); 
				return; 
			case AlePackage.ROPEN_CLASS:
				sequence_rOpenClass(context, (rOpenClass) semanticObject); 
>>>>>>> master:org.eclipse.ecoretools.ale.xtext/src-gen/org/eclipse/ecoretools/serializer/AleSemanticSequencer.java
				return; 
			case AlePackage.ROPERATION:
				sequence_rOperation(context, (rOperation) semanticObject); 
				return; 
			case AlePackage.RPARAMETERS:
				sequence_rParameters(context, (rParameters) semanticObject); 
				return; 
<<<<<<< HEAD:org.xtext.example.mydsl/src-gen/org/xtext/example/mydsl/serializer/MyDslSemanticSequencer.java
			case MyDslPackage.RVARIABLE:
=======
			case AlePackage.RROOT:
				sequence_rRoot(context, (rRoot) semanticObject); 
				return; 
			case AlePackage.RVARIABLE:
>>>>>>> master:org.eclipse.ecoretools.ale.xtext/src-gen/org/eclipse/ecoretools/serializer/AleSemanticSequencer.java
				sequence_rVariable(context, (rVariable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     nonLeftRecExpression returns expressionSequence
	 *     callExp returns expressionSequence
	 *     expressionSequence returns expressionSequence
	 *     literal returns expressionSequence
	 *
	 * Constraint:
	 *     (seqExprs+=expression seqExprs+=expression*)
	 */
	protected void sequence_expressionSequence(ISerializationContext context, expressionSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rVarDecl returns Expr
	 *     rCollection returns Expr
	 *     rExpression returns Expr
	 *     expression returns Expr
	 *     nonLeftRecExpression returns Expr
	 *     binding returns Expr
	 *     callExp returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression?)
	 */
	protected void sequence_expression(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rForEach returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression? block=rBlock)
	 */
	protected void sequence_expression_rForEach(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rWhile returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression? block=rBlock)
	 */
	protected void sequence_expression_rWhile(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recExpression returns Expr
	 *
	 * Constraint:
	 *     (leftPart=nonLeftRecExpression recpart=recExpression? recExp=recExpression?)
	 */
	protected void sequence_expression_recExpression(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     navigationSegment returns FinalCallExpSegment
	 *
	 * Constraint:
	 *     call=callExp
	 */
	protected void sequence_navigationSegment(ISerializationContext context, FinalCallExpSegment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FINAL_CALL_EXP_SEGMENT__CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FINAL_CALL_EXP_SEGMENT__CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationSegmentAccess().getCallCallExpParserRuleCall_2_2_0(), semanticObject.getCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     navigationSegment returns FinalIdentCallSegment
	 *
	 * Constraint:
	 *     call=callExp
	 */
	protected void sequence_navigationSegment(ISerializationContext context, FinalIdentCallSegment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FINAL_IDENT_CALL_SEGMENT__CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FINAL_IDENT_CALL_SEGMENT__CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationSegmentAccess().getCallCallExpParserRuleCall_1_2_0(), semanticObject.getCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     navigationSegment returns FinalIdentSegment
	 *
	 * Constraint:
	 *     ident=Ident
	 */
	protected void sequence_navigationSegment(ISerializationContext context, FinalIdentSegment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FINAL_IDENT_SEGMENT__IDENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FINAL_IDENT_SEGMENT__IDENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationSegmentAccess().getIdentIdentTerminalRuleCall_0_2_0(), semanticObject.getIdent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recExpression returns FinalCallExpSegment
	 *
	 * Constraint:
	 *     (call=callExp recExp=recExpression?)
	 */
	protected void sequence_navigationSegment_recExpression(ISerializationContext context, FinalCallExpSegment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recExpression returns FinalIdentCallSegment
	 *
	 * Constraint:
	 *     (call=callExp recExp=recExpression?)
	 */
	protected void sequence_navigationSegment_recExpression(ISerializationContext context, FinalIdentCallSegment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recExpression returns FinalIdentSegment
	 *
	 * Constraint:
	 *     (ident=Ident recExp=recExpression?)
	 */
	protected void sequence_navigationSegment_recExpression(ISerializationContext context, FinalIdentSegment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     nonLeftRecExpression returns nonLeftRecExpression
	 *
	 * Constraint:
	 *     ((condition=expression ifBlock=expression elseBlock=expression) | (bindings+=binding bindings+=binding* letExpr=expression))
	 */
	protected void sequence_nonLeftRecExpression(ISerializationContext context, nonLeftRecExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rAssign returns RAssign
	 *
	 * Constraint:
	 *     (left=expression right=expression)
	 */
	protected void sequence_rAssign(ISerializationContext context, RAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RASSIGN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RASSIGN__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RASSIGN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RASSIGN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRAssignAccess().getLeftExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRAssignAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rAttribute returns rAttribute
	 *
	 * Constraint:
	 *     (type=rType name=Ident expr=expression?)
	 */
	protected void sequence_rAttribute(ISerializationContext context, rAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rBlock returns rBlock
	 *
	 * Constraint:
	 *     (statement+=rStatement statement+=rStatement*)
	 */
	protected void sequence_rBlock(ISerializationContext context, rBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rClass returns RNewClass
	 *
	 * Constraint:
	 *     newClass=rNewClass
	 */
	protected void sequence_rClass(ISerializationContext context, RNewClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RNEW_CLASS__NEW_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RNEW_CLASS__NEW_CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRClassAccess().getNewClassRNewClassParserRuleCall_1_1_0(), semanticObject.getNewClass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rClass returns ROpenClass
	 *
	 * Constraint:
	 *     openClass=rOpenClass
	 */
	protected void sequence_rClass(ISerializationContext context, ROpenClass semanticObject) {
		if (errorAcceptor != null) {
<<<<<<< HEAD:org.xtext.example.mydsl/src-gen/org/xtext/example/mydsl/serializer/MyDslSemanticSequencer.java
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ROPEN_CLASS__OPEN_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ROPEN_CLASS__OPEN_CLASS));
=======
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RATTRIBUTE__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RATTRIBUTE__NAME));
>>>>>>> master:org.eclipse.ecoretools.ale.xtext/src-gen/org/eclipse/ecoretools/serializer/AleSemanticSequencer.java
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRClassAccess().getOpenClassROpenClassParserRuleCall_0_1_0(), semanticObject.getOpenClass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rForEach returns RForEach
	 *
	 * Constraint:
	 *     block=rBlock
	 */
	protected void sequence_rForEach(ISerializationContext context, RForEach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rIf returns RIf
	 *
	 * Constraint:
	 *     (condition=expression ifBlock=rBlock elseBlock=rBlock?)
	 */
	protected void sequence_rIf(ISerializationContext context, RIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rNewClass returns RNewClass
	 *
	 * Constraint:
	 *     (name=rQualified attributes+=rAttribute* operations+=rOperation*)
	 */
	protected void sequence_rNewClass(ISerializationContext context, RNewClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rOpenClass returns ROpenClass
	 *
	 * Constraint:
	 *     (name=rQualified attributes+=rAttribute* operations+=rOperation*)
	 */
	protected void sequence_rOpenClass(ISerializationContext context, ROpenClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rOperation returns rOperation
	 *
	 * Constraint:
	 *     (type=rType name=Ident paramList+=rParameters? body=rBlock)
	 */
	protected void sequence_rOperation(ISerializationContext context, rOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rParameters returns rParameters
	 *
	 * Constraint:
	 *     (params+=rVariable params+=rVariable*)
	 */
	protected void sequence_rParameters(ISerializationContext context, rParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rRoot returns RRoot
	 *
	 * Constraint:
	 *     xtendedClasses+=rClass+
	 */
	protected void sequence_rRoot(ISerializationContext context, RRoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RAssign
	 *
	 * Constraint:
	 *     stmt=rAssign
	 */
	protected void sequence_rStatement(ISerializationContext context, RAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RASSIGN__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RASSIGN__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getStmtRAssignParserRuleCall_1_1_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RExpression
	 *
	 * Constraint:
	 *     expr=rExpression
	 */
	protected void sequence_rStatement(ISerializationContext context, RExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getExprRExpressionParserRuleCall_5_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RForEach
	 *
	 * Constraint:
	 *     forEach=rForEach
	 */
	protected void sequence_rStatement(ISerializationContext context, RForEach semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RFOR_EACH__FOR_EACH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RFOR_EACH__FOR_EACH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getForEachRForEachParserRuleCall_2_1_0(), semanticObject.getForEach());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RIf
	 *
	 * Constraint:
	 *     if=rIf
	 */
	protected void sequence_rStatement(ISerializationContext context, RIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RIF__IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RIF__IF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getIfRIfParserRuleCall_4_1_0(), semanticObject.getIf());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RValDecl
	 *
	 * Constraint:
	 *     stmt=rVarDecl
	 */
	protected void sequence_rStatement(ISerializationContext context, RValDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RVAL_DECL__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RVAL_DECL__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getStmtRVarDeclParserRuleCall_0_1_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rStatement returns RWhile
	 *
	 * Constraint:
	 *     while=rWhile
	 */
	protected void sequence_rStatement(ISerializationContext context, RWhile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RWHILE__WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RWHILE__WHILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRStatementAccess().getWhileRWhileParserRuleCall_3_1_0(), semanticObject.getWhile());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rVariable returns rVariable
	 *
	 * Constraint:
	 *     (type=rType name=Ident)
	 */
	protected void sequence_rVariable(ISerializationContext context, rVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RVARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RVARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RVARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RVARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRVariableAccess().getTypeRTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getRVariableAccess().getNameIdentTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
