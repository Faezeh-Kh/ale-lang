/*
 * generated by Xtext 2.10.0
 */
package org.eclipse.ecoretools.validation

import org.eclipse.ecoretools.ale.typing.validation.AleTypingValidateValidator

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */

class AleValidator extends AleTypingValidateValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					AlePackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
// 		rVarDecl 
//		| rAssign
//		| rForEach
//		| rWhile
//		| rIf
//		| rExpression
//	@Check
//	def typecheckRVarDecl(RVarDecl vardecl) {
//		println('''vardecl «vardecl»''')
//	}
//
//	@Check
//	def typecheckAssign(RAssign assign) {
//		println('''assign «assign»''')
//	}
//	
//	@Check
//	def typecheckForEach(RForEach assign) {
//		println('''foreach «assign»''')
//	}
//	
//	@Check
//	def typecheckWhile(RWhile assign) {
//		println('''while «assign»''')
//	}
//	
//	@Check
//	def typecheckIf(RIf assign) {
//		println('''if «assign»''')
//	}
//	
//	@Check
//	def typecheckExpression(RExpression assign) {
//		println('''expression «assign»''')
//	}
//	
//	@Check
//	def typecheckNavigationSegment(NavigationSegment ns) {
//		println('''navigation segment «ns»''')
//	}
	
	int DUPLICATE_CLASS_NAME = 1
	
	int DUPLICATE_OPERATION_NAME = 2
	
//	@Check
//	def typecheckFinalIdentSegment(FinalIdentSegment finalIdentSegment) {
//		println('''FinalIdentSegment «finalIdentSegment.ident»''')
//	}
//
//	@Check
//	def typecheckFinalIdentCallSegment(FinalIdentCallSegment finalIdentCallSegment) {
//		println('''FinalIdentCallSegment «finalIdentCallSegment.call»''')
//	}
//
//	@Check
//	def typecheckFinalCallExpSegment(FinalCallExpSegment finalCallExpSegment) {
//		println('''FinalCallExpSegment «finalCallExpSegment.call»''')
//	}
//
//	@Check
//	def noDuplicateClasses(RRoot root) {
//		val duplicateClasses = root.xtendedClasses.groupBy[name].filter[p1, p2|p2.size > 1]
//		if (!duplicateClasses.empty) {
//			duplicateClasses.values.flatten.forEach [
//				error('Duplicated class name', it, AlePackage.Literals.RCLASS__NAME, DUPLICATE_CLASS_NAME)
//			]
//		}
//	}
//
//	@Check
//	def noDuplicateMethodsInClass(RClass openClass) {
//		// Note: We do not allow overloading for now.
//		val duplicateOperations = openClass.operations.groupBy[name].filter[p1, p2|p2.size > 1]
//		if (!duplicateOperations.empty) {
//			duplicateOperations.values.flatten.forEach [
//				error('Duplicate operation name', it, AlePackage.Literals.ROPERATION__NAME, DUPLICATE_OPERATION_NAME)
//			]
//		}
//	}

}
