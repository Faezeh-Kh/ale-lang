grammar org.eclipse.ecoretools.Ale with org.eclipse.xtext.common.Terminals

generate ale "http://www.eclipse.org/ecoretools/Ale"


/*****************
 *  ALE grammar  *
 *****************/

rRoot returns RRoot: 'behavior' rQualified ';' rImport* rService* xtendedClasses+=rClass*
;

rImport : 'import' rQualified 'as' IDENT ';'
;

rService : 'use' IDENT ('.' IDENT)* ';'
;

rClass returns RClass: 
	{ROpenClass} openClass=rOpenClass | 
	{RNewClass} newClass=rNewClass
;

rOpenClass returns ROpenClass: 'open' 'class' name=rQualified ('extends' rQualified (',' rQualified)* )? '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rNewClass returns RNewClass: 'class' name=rQualified '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rOperation : rTag* ('def' | 'override') type=rType name=IDENT '(' paramList+=rParameters? ')' body=rBlock
;

rTag : '@'IDENT
;

rParameters : params+=rVariable (',' params+=rVariable)*
;

rVariable : type=rType name=IDENT
;

rAttribute : type=rType name=IDENT (':=' expr=expression)? ';'
;

rStatement returns RStatement : 
	{RValDecl} stmt=rVarDecl | 
	{RAssign} stmt=rAssign | 
	{RForEach} forEach=rForEach | 
	{RWhile} while=rWhile | 
	{RIf} if=rIf | 
	{RExpression} expr=rExpression
;

rVarDecl : type=rType ident=IDENT (':=' expression=expression)? ';'
;

rAssign returns RAssign: left=expression ':=' right=expression ';'
;

rForEach returns RForEach: 'for' '(' IDENT  'in' rCollection ')' block=rBlock
;

rCollection : '[' INT '..' INT ']' | expression
;

rBlock : '{' (statement+=rStatement (statement+=rStatement)*)? '}'
;

rIf returns RIf: 'if' '(' condition=expression ')' ifBlock=rBlock ('else' elseBlock=rBlock)?
;

rWhile returns RWhile : 'while' '(' expression ')' block=rBlock
;

rExpression returns RExpression: expression ';'
;

/***************
 * AQL grammar *
 ***************/

expression returns Expr:
	leftPart=nonLeftRecExpression recpart=recExpression?
;

recExpression returns Expr:
	(navigationSegment | MULT_OP expression | ADD_OP expression | COMP_OP expression | 'and' expression | 'or' expression | 'xor' expression | 'implies' expression) recExp=recExpression?
;

navigationSegment returns NavigationSegment:     
	{FinalIdentSegment} '.'ident=IDENT | 
  	{FinalIdentCallSegment} '.' call=callExp | 
  	{FinalCallExpSegment} '->' call=callExp
;    

nonLeftRecExpression returns Expr:
              {NotExpression} 'not' expression=expression
		     | {NegExpression} '-' expression=expression
		     | {IdentifierExpresion} value=IDENT
		     | {LiteralExpressioin} lit=literal
		     | {ParenthesisExpression}'(' expression=expression ')'
		     | {IfExpression} 'if' condition=expression 'then' ifBlock=expression 'else' elseBlock=expression 'endif'
		     | {LetExpression} 'let' bindings+=binding (',' bindings+=binding)* 'in' letExpr=expression
;

binding returns Binding: identifier=IDENT (':' type=typeLiteral)? '=' expression=expression
;

terminal ADD_OP: '+' | '-'
;

terminal COMP_OP :     '<='
	    	|'>='
	  		|'!='
	  		|'<>'
	  		|'='
	  		|'=='
	 		|'<'
	  		|'>'
;


callExp returns ClassExp:     collectionIterator '(' variableDefinition expression=expression ')'
			| IDENT'(' expressionSequence ')'
;

collectionIterator : 'select' | 'reject' | 'collect' | 'any' | 'exists' | 'forAll' | 'isUnique' | 'one' | 'sortedBy' | 'closure'
;

expressionSequence : (seqExprs+=expression (',' seqExprs+=expression)*)?
;

variableDefinition : IDENT (':' typeLiteral)? '|'
;

literal returns Literal :    STRING
		   | INT
		   | REAL
		   |'true'
		   |'false'
		   |'null'
		   |'Sequence{' expressionSequence '}'
		   |'OrderedSet{' expressionSequence '}'
		   | IDENT '::' IDENT '::' IDENT
		   | IDENT '::' IDENT ':'
		   | typeLiteral
;

typeLiteral returns TypeLiteral : 
	{TypeLiteralString}   'String' |
	{TypeLiteralInteger} 'Integer' |
	{TypeLiteralReal} 'Real' | 
	{TypeLiteralBoolean} 'Boolean' |
	{TypeLiteralSequence} 'Sequence(' subType=typeLiteral')' | 
	{TypeLiteralOrderedTypeSet} 'OrderedSet(' subType=typeLiteral')' | 
	{TypeLiteralClassifier} classifierTypeRule | 
	{TypeLiteralPipe} '{' classifierTypeRule ('|' classifierTypeRule)* '}'
;

classifierTypeRule :   IDENT '::' IDENT
				     | IDENT ':' 
;

rType returns RType: rQualified | typeLiteral
;

rQualified : IDENT ('.'IDENT)*
;

terminal MULT_OP : '*' | '/'
;

terminal REAL : ('0'..'9')+'.'('0'..'9')+
;

terminal IDENT : (LETTER | '_') (LETTER | '0'..'9' | '_')*
;

terminal LETTER : ('a'..'z'|'A'..'Z')
;