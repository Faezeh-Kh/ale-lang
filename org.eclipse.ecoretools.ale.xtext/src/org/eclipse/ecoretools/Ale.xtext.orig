grammar org.eclipse.ecoretools.Ale with org.eclipse.xtext.common.Terminals

generate ale "http://www.eclipse.org/ecoretools/Ale"


/*****************
 *  ALE grammar  *
 *****************/

<<<<<<< HEAD
rRoot returns RRoot: 'behavior' rQualified ';' rImport* rService* xtendedClasses+=rClass*
;

rImport : 'import' rQualified 'as' IDENT ';'
;

rService : 'use' IDENT ('.' IDENT)* ';'
;

rClass returns RClass: 
	{ROpenClass} openClass=rOpenClass | 
	{RNewClass} newClass=rNewClass
;

rOpenClass returns ROpenClass: 'open' 'class' name=rQualified ('extends' rQualified (',' rQualified)* )? '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rNewClass returns RNewClass: 'class' name=rQualified '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rOperation : rTag* ('def' | 'override') type=rType name=IDENT '(' paramList+=rParameters? ')' body=rBlock
;

rTag : '@'IDENT
=======
rRoot : 'behavior' rQualified ';' rImport* rService* xtendedClasses+=rClass*
;

rImport : 'import' rQualified 'as' Ident ';'
;

rService : 'use' Ident ('.' Ident)* ';'
;

rClass : rOpenClass | rNewClass
;

rOpenClass : 'open' 'class' name=rQualified ('extends' rQualified (',' rQualified)* )? '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rNewClass : 'class' name=Ident '{' attributes+=rAttribute* operations+=rOperation* '}'
;

rOperation : rTag* ('def' | 'override') type=rType name=Ident '(' paramList+=rParameters? ')' body=rBlock
;

rTag : '@'Ident
>>>>>>> local-ale-lang
;

rParameters : params+=rVariable (',' params+=rVariable)*
;

<<<<<<< HEAD
rVariable : type=rType name=IDENT
;

rAttribute : type=rType name=IDENT (':=' expr=expression)? ';'
;

rStatement returns RStatement : 
	{RValDecl} stmt=rVarDecl | 
	{RAssign} stmt=rAssign | 
	{RForEach} forEach=rForEach | 
	{RWhile} while=rWhile | 
	{RIf} if=rIf | 
	{RExpression} expr=rExpression
;

rVarDecl : type=rType ident=IDENT (':=' expression=expression)? ';'
;

rAssign returns RAssign: left=expression ':=' right=expression ';'
;

rForEach returns RForEach: 'for' '(' IDENT  'in' rCollection ')' block=rBlock
=======
rVariable : type=rType name=Ident
;

rAttribute : type=rType name=Ident (':=' expression)? ';'
;

rStatement : rVarDecl 
		| rAssign
		| rForEach
		| rWhile
		| rIf
		| rExpression
;

rVarDecl : rType Ident (':=' expression)? ';'
;

rAssign : expression ':=' expression ';'
;

rForEach : 'for' '(' Ident  'in' rCollection ')' rBlock
>>>>>>> local-ale-lang
;

rCollection : '[' INT '..' INT ']' | expression
;

<<<<<<< HEAD
rBlock : '{' (statement+=rStatement (statement+=rStatement)*)? '}'
;

rIf returns RIf: 'if' '(' condition=expression ')' ifBlock=rBlock ('else' elseBlock=rBlock)?
;

rWhile returns RWhile : 'while' '(' expression ')' block=rBlock
;

rExpression returns RExpression: expression ';'
=======
rBlock : '{' (rStatement (rStatement)*)? '}'
;

rIf : 'if' '(' expression ')' rBlock ('else' rBlock)?
;

rWhile : 'while' '(' expression ')' rBlock
;

rExpression : expression ';'
>>>>>>> local-ale-lang
;

/***************
 * AQL grammar *
 ***************/

<<<<<<< HEAD
expression returns Expr:
	leftPart=nonLeftRecExpression recpart=recExpression?
;

recExpression returns Expr:
	(navigationSegment | MULT_OP expression | ADD_OP expression | COMP_OP expression | 'and' expression | 'or' expression | 'xor' expression | 'implies' expression) recExp=recExpression?
;

navigationSegment returns NavigationSegment:     
	{FinalIdentSegment} '.'ident=IDENT | 
  	{FinalIdentCallSegment} '.' call=callExp | 
  	{FinalCallExpSegment} '->' call=callExp
;    

nonLeftRecExpression returns Expr:
              {NotExpression} 'not' expression=expression
		     | {NegExpression} '-' expression=expression
		     | {IdentifierExpresion} value=IDENT
		     | {LiteralExpressioin} lit=literal
		     | {ParenthesisExpression}'(' expression=expression ')'
		     | {IfExpression} 'if' condition=expression 'then' ifBlock=expression 'else' elseBlock=expression 'endif'
		     | {LetExpression} 'let' bindings+=binding (',' bindings+=binding)* 'in' letExpr=expression
;

binding returns Binding: identifier=IDENT (':' type=typeLiteral)? '=' expression=expression
;

terminal ADD_OP: '+' | '-'
;

terminal COMP_OP :     '<='
=======
expression :
	nonLeftRecExpression recExpression?
;

recExpression :
	(navigationSegment | MultOp expression | addOp expression | compOp expression | 'and' expression | 'or' expression | 'xor' expression | 'implies' expression) recExpression?
;

navigationSegment :     '.'Ident
				      | '.' callExp
				      | '->' callExp
;    

nonLeftRecExpression :
              'not' expression
		     | '-' expression
		     | Ident
		     | literal
		     | '(' expression ')'
		     | 'if' expression 'then' expression 'else' expression 'endif'
		     | 'let' binding (',' binding)* 'in' expression
;

binding : Ident (':' typeLiteral)? '=' expression
;

addOp: '+' | '-'
;

compOp :     '<='
>>>>>>> local-ale-lang
	    	|'>='
	  		|'!='
	  		|'<>'
	  		|'='
	  		|'=='
	 		|'<'
	  		|'>'
;


<<<<<<< HEAD
callExp returns ClassExp:     collectionIterator '(' variableDefinition expression=expression ')'
			| IDENT'(' expressionSequence ')'
=======
callExp :     collectionIterator '(' variableDefinition lambdaExpression ')'
			| Ident'(' expressionSequence ')'
;

lambdaExpression : expression
>>>>>>> local-ale-lang
;

collectionIterator : 'select' | 'reject' | 'collect' | 'any' | 'exists' | 'forAll' | 'isUnique' | 'one' | 'sortedBy' | 'closure'
;

<<<<<<< HEAD
expressionSequence : (seqExprs+=expression (',' seqExprs+=expression)*)?
;

variableDefinition : IDENT (':' typeLiteral)? '|'
;

literal returns Literal :    STRING
		   | INT
		   | REAL
=======
expressionSequence : (expression (',' expression)*)?
;

variableDefinition : Ident (':' typeLiteral)? '|'
;

literal :    STRING
		   | INT
		   | Real
>>>>>>> local-ale-lang
		   |'true'
		   |'false'
		   |'null'
		   |'Sequence{' expressionSequence '}'
		   |'OrderedSet{' expressionSequence '}'
<<<<<<< HEAD
		   | IDENT '::' IDENT '::' IDENT
		   | IDENT '::' IDENT ':'
		   | typeLiteral
;

typeLiteral returns TypeLiteral : 
	{TypeLiteralString}   'String' |
	{TypeLiteralInteger} 'Integer' |
	{TypeLiteralReal} 'Real' | 
	{TypeLiteralBoolean} 'Boolean' |
	{TypeLiteralSequence} 'Sequence(' subType=typeLiteral')' | 
	{TypeLiteralOrderedTypeSet} 'OrderedSet(' subType=typeLiteral')' | 
	{TypeLiteralClassifier} classifierTypeRule | 
	{TypeLiteralPipe} '{' classifierTypeRule ('|' classifierTypeRule)* '}'
;

classifierTypeRule :   IDENT '::' IDENT
				     | IDENT ':' 
;

rType returns RType: rQualified | typeLiteral
;

rQualified : IDENT ('.'IDENT)*
;

terminal MULT_OP : '*' | '/'
;

terminal REAL : ('0'..'9')+'.'('0'..'9')+
;

terminal IDENT : (LETTER | '_') (LETTER | '0'..'9' | '_')*
;

terminal LETTER : ('a'..'z'|'A'..'Z')
;
=======
		   | Ident '::' Ident '::' Ident
		   | Ident '::' Ident ':'
		   | typeLiteral
;

typeLiteral :   'String'
		      | 'Integer'
		      | 'Real'
		      | 'Boolean'
		      | 'Sequence(' typeLiteral')'
		      | 'OrderedSet(' typeLiteral')'
		      | classifierTypeRule
		      | '{' classifierTypeRule ('|' classifierTypeRule)* '}'
;

classifierTypeRule :   Ident '::' Ident
				     | Ident ':' 
;

rType: rQualified | typeLiteral
;

rQualified : Ident ('.'Ident)*
;

terminal MultOp : '*' | '/'
;

terminal Real : ('0'..'9')+'.'('0'..'9')+
;

terminal Ident : (Letter | '_') (Letter | '0'..'9' | '_')*
;

terminal Letter : ('a'..'z'|'A'..'Z')
;
>>>>>>> local-ale-lang
